# 0068: ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒãƒ¥ãƒ¼ãƒ‹ãƒ³ã‚°ã¨æœ€é©åŒ–

## èª¬æ˜
ã‚·ã‚¹ãƒ†ãƒ å…¨ä½“ã®ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ã‚’åˆ†æã—ã€ãƒœãƒˆãƒ«ãƒãƒƒã‚¯ã‚’ç‰¹å®šã—ã¦æœ€é©åŒ–ã‚’å®Ÿæ–½ã™ã‚‹ã€‚ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã‚¯ã‚¨ãƒªã®æœ€é©åŒ–ã€ã‚­ãƒ£ãƒƒã‚·ãƒ¥æˆ¦ç•¥ã®æ”¹å–„ã€APIãƒ¬ã‚¹ãƒãƒ³ã‚¹ã‚¿ã‚¤ãƒ ã®çŸ­ç¸®ã€ãƒ¡ãƒ¢ãƒªä½¿ç”¨é‡ã®å‰Šæ¸›ã€Edge Functionã®æœ€é©åŒ–ãªã©ã€ã‚¨ãƒ³ãƒ‰ãƒ„ãƒ¼ã‚¨ãƒ³ãƒ‰ã®ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æ”¹å–„ã‚’è¡Œã†ã€‚

## ã‚¿ã‚¹ã‚¯ç¨®åˆ¥
- [x] æ©Ÿèƒ½å®Ÿè£…
- [ ] ãƒã‚°ä¿®æ­£
- [ ] ãƒªãƒ•ã‚¡ã‚¯ã‚¿ãƒªãƒ³ã‚°
- [ ] ãƒ†ã‚¹ãƒˆ
- [ ] ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ
- [ ] èª¿æŸ»

## å„ªå…ˆåº¦
ä¸­

## è¦‹ç©ã‚‚ã‚Šå·¥æ•°
[ã‚¹ãƒˆãƒ¼ãƒªãƒ¼ãƒã‚¤ãƒ³ãƒˆ: 3] (ç´„1æ—¥)

## ä¾å­˜é–¢ä¿‚
- å‰æã‚¿ã‚¹ã‚¯: #0056, #0062
- é–¢é€£ã‚¿ã‚¹ã‚¯: #0066

## å—ã‘å…¥ã‚ŒåŸºæº–
- [ ] ä¸»è¦APIã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆã®ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã‚¿ã‚¤ãƒ ãŒP95ã§500msä»¥ä¸‹
- [ ] ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã‚¯ã‚¨ãƒªã®å®Ÿè¡Œæ™‚é–“ãŒ100msä»¥ä¸‹
- [ ] ã‚­ãƒ£ãƒƒã‚·ãƒ¥ãƒ’ãƒƒãƒˆç‡ãŒ80%ä»¥ä¸Š
- [ ] ãƒ¡ãƒ¢ãƒªä½¿ç”¨é‡ãŒå®‰å®šã—ã¦ã„ã‚‹ï¼ˆãƒªãƒ¼ã‚¯ãŒãªã„ï¼‰
- [ ] åŒæ™‚æ¥ç¶šæ•°1000ã§ã‚‚å®‰å®šå‹•ä½œã™ã‚‹
- [ ] ã‚³ãƒ¼ãƒ«ãƒ‰ã‚¹ã‚¿ãƒ¼ãƒˆæ™‚é–“ãŒ1ç§’ä»¥ä¸‹
- [ ] ãƒãƒ³ãƒ‰ãƒ«ã‚µã‚¤ã‚ºãŒæœ€é©åŒ–ã•ã‚Œã¦ã„ã‚‹
- [ ] ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æ”¹å–„ãƒ¬ãƒãƒ¼ãƒˆãŒä½œæˆã•ã‚Œã¦ã„ã‚‹

## æŠ€è¡“çš„ãªè©³ç´°
### ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹åˆ†æã‚¹ã‚¯ãƒªãƒ—ãƒˆ
```typescript
// scripts/performance/analyze.ts
import { performance } from 'perf_hooks';
import { createClient } from '@supabase/supabase-js';
import axios from 'axios';
import pMap from 'p-map';

interface PerformanceMetrics {
  endpoint: string;
  method: string;
  samples: number;
  min: number;
  max: number;
  mean: number;
  median: number;
  p95: number;
  p99: number;
}

class PerformanceAnalyzer {
  private metrics: Map<string, number[]> = new Map();
  
  constructor(
    private apiUrl: string,
    private authToken: string
  ) {}

  async analyzeEndpoints() {
    console.log('ğŸ” Starting Performance Analysis...\n');
    
    const endpoints = [
      { path: '/health', method: 'GET', auth: false },
      { path: '/secure/test/data.json', method: 'GET', auth: true },
      { path: '/auth/login', method: 'POST', auth: false },
      { path: '/api-docs', method: 'GET', auth: false },
    ];

    // ã‚¦ã‚©ãƒ¼ãƒ ã‚¢ãƒƒãƒ—
    console.log('ğŸ“Š Warming up...');
    await this.warmup(endpoints);

    // æ¸¬å®š
    console.log('\nğŸ“ Measuring performance...');
    for (const endpoint of endpoints) {
      await this.measureEndpoint(endpoint);
    }

    // çµæœã®é›†è¨ˆã¨è¡¨ç¤º
    this.generateReport();
  }

  private async warmup(endpoints: any[]) {
    // å„ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆã‚’5å›å‘¼ã³å‡ºã—ã¦ã‚¦ã‚©ãƒ¼ãƒ ã‚¢ãƒƒãƒ—
    await pMap(endpoints, async (endpoint) => {
      for (let i = 0; i < 5; i++) {
        await this.callEndpoint(endpoint);
      }
    }, { concurrency: 5 });
  }

  private async measureEndpoint(endpoint: any, samples: number = 100) {
    const key = `${endpoint.method} ${endpoint.path}`;
    const measurements: number[] = [];

    console.log(`\nMeasuring ${key}...`);
    
    for (let i = 0; i < samples; i++) {
      const start = performance.now();
      await this.callEndpoint(endpoint);
      const duration = performance.now() - start;
      measurements.push(duration);
      
      if ((i + 1) % 10 === 0) {
        process.stdout.write(`\r  Progress: ${i + 1}/${samples}`);
      }
    }

    this.metrics.set(key, measurements);
  }

  private async callEndpoint(endpoint: any) {
    const headers: any = {};
    if (endpoint.auth) {
      headers.Authorization = `Bearer ${this.authToken}`;
    }

    try {
      if (endpoint.method === 'POST') {
        await axios.post(`${this.apiUrl}${endpoint.path}`, 
          endpoint.body || {},
          { headers, timeout: 10000 }
        );
      } else {
        await axios.get(`${this.apiUrl}${endpoint.path}`, 
          { headers, timeout: 10000 }
        );
      }
    } catch (error) {
      // ã‚¨ãƒ©ãƒ¼ã‚‚æ¸¬å®šå¯¾è±¡ã«å«ã‚ã‚‹
    }
  }

  private generateReport() {
    console.log('\n\nğŸ“Š Performance Analysis Report\n');
    console.log('=' .repeat(80));

    const results: PerformanceMetrics[] = [];

    for (const [endpoint, measurements] of this.metrics) {
      const sorted = measurements.sort((a, b) => a - b);
      const result: PerformanceMetrics = {
        endpoint,
        method: endpoint.split(' ')[0],
        samples: measurements.length,
        min: Math.min(...measurements),
        max: Math.max(...measurements),
        mean: measurements.reduce((a, b) => a + b) / measurements.length,
        median: sorted[Math.floor(sorted.length / 2)],
        p95: sorted[Math.floor(sorted.length * 0.95)],
        p99: sorted[Math.floor(sorted.length * 0.99)],
      };
      results.push(result);

      console.log(`\n${endpoint}:`);
      console.log(`  Samples: ${result.samples}`);
      console.log(`  Min: ${result.min.toFixed(2)}ms`);
      console.log(`  Max: ${result.max.toFixed(2)}ms`);
      console.log(`  Mean: ${result.mean.toFixed(2)}ms`);
      console.log(`  Median: ${result.median.toFixed(2)}ms`);
      console.log(`  P95: ${result.p95.toFixed(2)}ms`);
      console.log(`  P99: ${result.p99.toFixed(2)}ms`);
    }

    // å•é¡Œã®ã‚ã‚‹ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆã‚’ç‰¹å®š
    console.log('\nâš ï¸  Performance Issues:');
    const issues = results.filter(r => r.p95 > 500);
    if (issues.length === 0) {
      console.log('  âœ… All endpoints meet performance targets!');
    } else {
      issues.forEach(issue => {
        console.log(`  âŒ ${issue.endpoint}: P95 = ${issue.p95.toFixed(2)}ms (target: < 500ms)`);
      });
    }
  }
}

// ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹åˆ†æ
class DatabasePerformanceAnalyzer {
  constructor(private supabase: any) {}

  async analyzeDatabasePerformance() {
    console.log('\nğŸ—„ï¸  Database Performance Analysis\n');

    // ã‚¹ãƒ­ãƒ¼ã‚¯ã‚¨ãƒªã®åˆ†æ
    const slowQueries = await this.getSlowQueries();
    if (slowQueries.length > 0) {
      console.log('ğŸŒ Slow Queries:');
      slowQueries.forEach(query => {
        console.log(`  - ${query.query}`);
        console.log(`    Mean time: ${query.mean_time.toFixed(2)}ms`);
        console.log(`    Calls: ${query.calls}`);
      });
    }

    // ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã®ä½¿ç”¨çŠ¶æ³
    const unusedIndexes = await this.getUnusedIndexes();
    if (unusedIndexes.length > 0) {
      console.log('\nğŸ“‘ Unused Indexes:');
      unusedIndexes.forEach(index => {
        console.log(`  - ${index.schemaname}.${index.tablename}.${index.indexname}`);
      });
    }

    // ãƒ†ãƒ¼ãƒ–ãƒ«ã‚µã‚¤ã‚ºã¨ãƒ–ãƒ­ãƒ¼ãƒˆ
    const tableSizes = await this.getTableSizes();
    console.log('\nğŸ“Š Table Sizes:');
    tableSizes.forEach(table => {
      console.log(`  - ${table.tablename}: ${table.size}`);
      if (table.bloat_ratio > 20) {
        console.log(`    âš ï¸  High bloat: ${table.bloat_ratio}%`);
      }
    });
  }

  private async getSlowQueries() {
    const { data } = await this.supabase.rpc('get_slow_queries');
    return data || [];
  }

  private async getUnusedIndexes() {
    const { data } = await this.supabase.rpc('get_unused_indexes');
    return data || [];
  }

  private async getTableSizes() {
    const { data } = await this.supabase.rpc('get_table_sizes');
    return data || [];
  }
}
```

### ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹æœ€é©åŒ–
```sql
-- scripts/performance/database-optimization.sql

-- 1. ã‚¹ãƒ­ãƒ¼ã‚¯ã‚¨ãƒªåˆ†æç”¨ã®é–¢æ•°
CREATE OR REPLACE FUNCTION get_slow_queries()
RETURNS TABLE (
  query text,
  calls bigint,
  total_time double precision,
  mean_time double precision,
  max_time double precision
) AS $$
BEGIN
  RETURN QUERY
  SELECT 
    pss.query,
    pss.calls,
    pss.total_exec_time as total_time,
    pss.mean_exec_time as mean_time,
    pss.max_exec_time as max_time
  FROM pg_stat_statements pss
  WHERE pss.mean_exec_time > 100  -- 100msä»¥ä¸Š
  ORDER BY pss.mean_exec_time DESC
  LIMIT 20;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- 2. ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹æœ€é©åŒ–
-- ä½¿ç”¨é »åº¦ã®é«˜ã„ã‚¯ã‚¨ãƒªç”¨ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹
CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_api_logs_user_created 
  ON api_logs(user_id, created_at DESC);

CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_api_logs_endpoint_method 
  ON api_logs(endpoint, method);

CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_rate_limit_logs_user_window 
  ON rate_limit_logs(user_id, window_start);

-- éƒ¨åˆ†ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ï¼ˆç‰¹å®šæ¡ä»¶ã®ã‚¯ã‚¨ãƒªæœ€é©åŒ–ï¼‰
CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_api_logs_errors 
  ON api_logs(created_at DESC) 
  WHERE response_code >= 400;

-- 3. ãƒ‘ãƒ¼ãƒ†ã‚£ã‚·ãƒ§ãƒ‹ãƒ³ã‚°è¨­å®šï¼ˆå¤§é‡ãƒ‡ãƒ¼ã‚¿å¯¾å¿œï¼‰
-- api_logsãƒ†ãƒ¼ãƒ–ãƒ«ã®æœˆæ¬¡ãƒ‘ãƒ¼ãƒ†ã‚£ã‚·ãƒ§ãƒ³
CREATE TABLE IF NOT EXISTS api_logs_2025_01 PARTITION OF api_logs
  FOR VALUES FROM ('2025-01-01') TO ('2025-02-01');

CREATE TABLE IF NOT EXISTS api_logs_2025_02 PARTITION OF api_logs
  FOR VALUES FROM ('2025-02-01') TO ('2025-03-01');

-- 4. çµ±è¨ˆæƒ…å ±ã®æ›´æ–°
ANALYZE api_logs;
ANALYZE rate_limit_logs;
ANALYZE auth_logs;

-- 5. è‡ªå‹•ãƒã‚­ãƒ¥ãƒ¼ãƒ è¨­å®šã®æœ€é©åŒ–
ALTER TABLE api_logs SET (
  autovacuum_vacuum_scale_factor = 0.1,
  autovacuum_analyze_scale_factor = 0.05
);
```

### ã‚­ãƒ£ãƒƒã‚·ãƒ¥æœ€é©åŒ–
```typescript
// src/performance/cache-strategy.ts
import { LRUCache } from 'lru-cache';
import { createHash } from 'crypto';
import { FastifyInstance } from 'fastify';

interface CacheOptions {
  ttl: number;
  max: number;
  sizeCalculation?: (value: any) => number;
}

export class CacheManager {
  private caches: Map<string, LRUCache<string, any>> = new Map();
  private stats = {
    hits: 0,
    misses: 0,
    sets: 0,
    deletes: 0,
  };

  constructor() {
    // å„ç¨®ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã®åˆæœŸåŒ–
    this.initializeCaches();
  }

  private initializeCaches() {
    // APIãƒ¬ã‚¹ãƒãƒ³ã‚¹ã‚­ãƒ£ãƒƒã‚·ãƒ¥
    this.caches.set('api-response', new LRUCache<string, any>({
      max: 1000,
      ttl: 5 * 60 * 1000, // 5åˆ†
      sizeCalculation: (value) => JSON.stringify(value).length,
      maxSize: 50 * 1024 * 1024, // 50MB
    }));

    // ãƒ¦ãƒ¼ã‚¶ãƒ¼æƒ…å ±ã‚­ãƒ£ãƒƒã‚·ãƒ¥
    this.caches.set('user-data', new LRUCache<string, any>({
      max: 10000,
      ttl: 30 * 60 * 1000, // 30åˆ†
    }));

    // ãƒ¬ãƒ¼ãƒˆåˆ¶é™ã‚«ã‚¦ãƒ³ãƒˆã‚­ãƒ£ãƒƒã‚·ãƒ¥
    this.caches.set('rate-limit', new LRUCache<string, any>({
      max: 50000,
      ttl: 60 * 1000, // 1åˆ†ï¼ˆã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã‚µã‚¤ã‚ºã«åˆã‚ã›ã‚‹ï¼‰
    }));
  }

  async get(cacheName: string, key: string): Promise<any | null> {
    const cache = this.caches.get(cacheName);
    if (!cache) return null;

    const value = cache.get(key);
    if (value !== undefined) {
      this.stats.hits++;
      return value;
    }

    this.stats.misses++;
    return null;
  }

  async set(cacheName: string, key: string, value: any, ttl?: number): Promise<void> {
    const cache = this.caches.get(cacheName);
    if (!cache) return;

    cache.set(key, value, { ttl });
    this.stats.sets++;
  }

  async delete(cacheName: string, key: string): Promise<void> {
    const cache = this.caches.get(cacheName);
    if (!cache) return;

    cache.delete(key);
    this.stats.deletes++;
  }

  generateCacheKey(prefix: string, params: any): string {
    const hash = createHash('sha256');
    hash.update(prefix);
    hash.update(JSON.stringify(params));
    return hash.digest('hex');
  }

  getStats() {
    const hitRate = this.stats.hits / (this.stats.hits + this.stats.misses) || 0;
    return {
      ...this.stats,
      hitRate: (hitRate * 100).toFixed(2) + '%',
      cacheInfo: Array.from(this.caches.entries()).map(([name, cache]) => ({
        name,
        size: cache.size,
        maxSize: cache.max,
      })),
    };
  }

  // ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚¦ã‚©ãƒ¼ãƒŸãƒ³ã‚°
  async warmupCache() {
    console.log('ğŸ”¥ Warming up caches...');
    
    // ã‚ˆãã‚¢ã‚¯ã‚»ã‚¹ã•ã‚Œã‚‹ãƒ‡ãƒ¼ã‚¿ã‚’äº‹å‰ã«ã‚­ãƒ£ãƒƒã‚·ãƒ¥
    const popularEndpoints = [
      '/secure/popular/dataset1.json',
      '/secure/popular/dataset2.json',
      '/secure/popular/dataset3.json',
    ];

    for (const endpoint of popularEndpoints) {
      // ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—ã—ã¦ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã«æ ¼ç´
      const data = await this.fetchData(endpoint);
      const key = this.generateCacheKey('api-response', { endpoint });
      await this.set('api-response', key, data);
    }
  }

  private async fetchData(endpoint: string): Promise<any> {
    // å®Ÿéš›ã®ãƒ‡ãƒ¼ã‚¿å–å¾—ãƒ­ã‚¸ãƒƒã‚¯
    return {};
  }
}

// Fastifyãƒ—ãƒ©ã‚°ã‚¤ãƒ³
export const cachePlugin = async (fastify: FastifyInstance) => {
  const cacheManager = new CacheManager();
  
  // ã‚­ãƒ£ãƒƒã‚·ãƒ¥ãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ã‚’ãƒ‡ã‚³ãƒ¬ãƒ¼ã‚¿ã¨ã—ã¦ç™»éŒ²
  fastify.decorate('cache', cacheManager);

  // ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã‚­ãƒ£ãƒƒã‚·ãƒ¥ãƒ•ãƒƒã‚¯
  fastify.addHook('onRequest', async (request, reply) => {
    // GET ãƒªã‚¯ã‚¨ã‚¹ãƒˆã®ã¿ã‚­ãƒ£ãƒƒã‚·ãƒ¥
    if (request.method !== 'GET') return;

    const cacheKey = cacheManager.generateCacheKey('api-response', {
      url: request.url,
      userId: request.user?.id,
    });

    const cachedResponse = await cacheManager.get('api-response', cacheKey);
    if (cachedResponse) {
      reply.header('X-Cache', 'HIT');
      reply.send(cachedResponse);
    }
  });

  fastify.addHook('onSend', async (request, reply, payload) => {
    // ã‚­ãƒ£ãƒƒã‚·ãƒ¥ãƒŸã‚¹ã®å ´åˆã€ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã‚’ã‚­ãƒ£ãƒƒã‚·ãƒ¥
    if (
      request.method === 'GET' &&
      reply.statusCode === 200 &&
      !reply.hasHeader('X-Cache')
    ) {
      const cacheKey = cacheManager.generateCacheKey('api-response', {
        url: request.url,
        userId: request.user?.id,
      });

      await cacheManager.set('api-response', cacheKey, payload);
      reply.header('X-Cache', 'MISS');
    }
  });

  // ã‚­ãƒ£ãƒƒã‚·ãƒ¥çµ±è¨ˆã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆ
  fastify.get('/cache/stats', async (request, reply) => {
    return cacheManager.getStats();
  });
};
```

### Edge Functionæœ€é©åŒ–
```typescript
// src/performance/edge-optimization.ts
import { FastifyInstance } from 'fastify';

export class EdgeOptimizer {
  // ãƒ¬ã‚¹ãƒãƒ³ã‚¹åœ§ç¸®ã®æœ€é©åŒ–
  static configureCompression(app: FastifyInstance) {
    app.register(import('@fastify/compress'), {
      global: true,
      threshold: 1024, // 1KBä»¥ä¸Šã®ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã‚’åœ§ç¸®
      encodings: ['gzip', 'deflate', 'br'],
      // åœ§ç¸®ãƒ¬ãƒ™ãƒ«ã®æœ€é©åŒ–
      brotliOptions: {
        params: {
          [require('zlib').constants.BROTLI_PARAM_QUALITY]: 4,
        },
      },
      zlibOptions: {
        level: 6,
      },
    });
  }

  // ã‚³ãƒã‚¯ã‚·ãƒ§ãƒ³ãƒ—ãƒ¼ãƒªãƒ³ã‚°ã®æœ€é©åŒ–
  static optimizeConnections() {
    // Keep-Aliveè¨­å®š
    return {
      server: {
        keepAliveTimeout: 5000,
        maxRequestsPerSocket: 0, // ç„¡åˆ¶é™
      },
      http2: {
        sessionTimeout: 60000,
      },
    };
  }

  // ã‚³ãƒ¼ãƒ«ãƒ‰ã‚¹ã‚¿ãƒ¼ãƒˆæœ€é©åŒ–
  static async warmupFunction() {
    console.log('ğŸš€ Warming up Edge Function...');
    
    // å¿…è¦ãªãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®äº‹å‰ãƒ­ãƒ¼ãƒ‰
    const criticalModules = [
      '@supabase/supabase-js',
      'fastify',
      '@fastify/cors',
      '@fastify/helmet',
    ];

    for (const module of criticalModules) {
      require(module);
    }

    // ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹æ¥ç¶šã®äº‹å‰ç¢ºç«‹
    // await establishDatabaseConnection();
    
    // ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã®äº‹å‰ãƒ­ãƒ¼ãƒ‰
    // await preloadCache();
  }

  // ãƒ¡ãƒ¢ãƒªä½¿ç”¨é‡ã®æœ€é©åŒ–
  static monitorMemoryUsage() {
    const used = process.memoryUsage();
    const stats = {
      rss: `${Math.round(used.rss / 1024 / 1024)}MB`,
      heapTotal: `${Math.round(used.heapTotal / 1024 / 1024)}MB`,
      heapUsed: `${Math.round(used.heapUsed / 1024 / 1024)}MB`,
      external: `${Math.round(used.external / 1024 / 1024)}MB`,
    };

    // ãƒ¡ãƒ¢ãƒªãƒªãƒ¼ã‚¯ã®æ¤œå‡º
    if (used.heapUsed / used.heapTotal > 0.9) {
      console.warn('âš ï¸  High memory usage detected:', stats);
      // ã‚¬ãƒ™ãƒ¼ã‚¸ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ã®å¼·åˆ¶å®Ÿè¡Œ
      if (global.gc) {
        global.gc();
      }
    }

    return stats;
  }
}

// ãƒãƒ³ãƒ‰ãƒ«ã‚µã‚¤ã‚ºæœ€é©åŒ–è¨­å®š
export const bundleOptimization = {
  build: {
    minify: true,
    target: 'node18',
    treeShaking: true,
    bundle: true,
    splitting: false, // ã‚µãƒ¼ãƒãƒ¼ã‚µã‚¤ãƒ‰ã§ã¯ä¸è¦
    external: [
      // ãƒã‚¤ãƒ†ã‚£ãƒ–ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯å¤–éƒ¨åŒ–
      'bcrypt',
      'sharp',
      '@prisma/client',
    ],
  },
  esbuild: {
    // ä¸è¦ãªã‚½ãƒ¼ã‚¹ãƒãƒƒãƒ—ã‚’å‰Šé™¤
    sourcemap: false,
    // console.logã®å‰Šé™¤ï¼ˆæœ¬ç•ªç’°å¢ƒï¼‰
    drop: process.env.NODE_ENV === 'production' ? ['console', 'debugger'] : [],
    // æœ€é©åŒ–ãƒ¬ãƒ™ãƒ«
    minify: true,
    minifyWhitespace: true,
    minifyIdentifiers: true,
    minifySyntax: true,
  },
};
```

### ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æ”¹å–„ãƒ¬ãƒãƒ¼ãƒˆ
```markdown
# ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æ”¹å–„ãƒ¬ãƒãƒ¼ãƒˆ

## ã‚¨ã‚°ã‚¼ã‚¯ãƒ†ã‚£ãƒ–ã‚µãƒãƒªãƒ¼

æœ¬ãƒ¬ãƒãƒ¼ãƒˆã¯ã€Open Data APIã®ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹åˆ†æã¨æœ€é©åŒ–ã®çµæœã‚’ã¾ã¨ã‚ãŸã‚‚ã®ã§ã™ã€‚

### ä¸»è¦ãªæ”¹å–„æˆæœ

| ãƒ¡ãƒˆãƒªã‚¯ã‚¹ | æ”¹å–„å‰ | æ”¹å–„å¾Œ | æ”¹å–„ç‡ |
|-----------|--------|--------|--------|
| API ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã‚¿ã‚¤ãƒ  (P95) | 850ms | 420ms | -51% |
| ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã‚¯ã‚¨ãƒªæ™‚é–“ (å¹³å‡) | 180ms | 45ms | -75% |
| ã‚­ãƒ£ãƒƒã‚·ãƒ¥ãƒ’ãƒƒãƒˆç‡ | 45% | 85% | +89% |
| ãƒ¡ãƒ¢ãƒªä½¿ç”¨é‡ | 512MB | 380MB | -26% |
| ã‚³ãƒ¼ãƒ«ãƒ‰ã‚¹ã‚¿ãƒ¼ãƒˆæ™‚é–“ | 3.2s | 0.9s | -72% |

## å®Ÿæ–½ã—ãŸæœ€é©åŒ–

### 1. ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹æœ€é©åŒ–

#### ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹è¿½åŠ 
```sql
-- é »ç¹ã«ã‚¢ã‚¯ã‚»ã‚¹ã•ã‚Œã‚‹ã‚«ãƒ©ãƒ ã«ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’è¿½åŠ 
CREATE INDEX idx_api_logs_user_created ON api_logs(user_id, created_at DESC);
CREATE INDEX idx_rate_limit_logs_user_window ON rate_limit_logs(user_id, window_start);
```

**åŠ¹æœ**: ã‚¯ã‚¨ãƒªå®Ÿè¡Œæ™‚é–“ãŒå¹³å‡180msã‹ã‚‰45msã«çŸ­ç¸®

#### ã‚¯ã‚¨ãƒªæœ€é©åŒ–
- N+1å•é¡Œã®è§£æ¶ˆ
- ä¸è¦ãªJOINã®å‰Šé™¤
- ãƒãƒƒãƒå‡¦ç†ã®å°å…¥

### 2. ã‚­ãƒ£ãƒƒã‚·ãƒ¥æˆ¦ç•¥

#### å¤šå±¤ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã®å®Ÿè£…
1. **Edge ã‚­ãƒ£ãƒƒã‚·ãƒ¥**: CDNãƒ¬ãƒ™ãƒ«ï¼ˆ5åˆ†ï¼‰
2. **ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã‚­ãƒ£ãƒƒã‚·ãƒ¥**: ãƒ¡ãƒ¢ãƒªå†…LRUï¼ˆ1åˆ†ï¼‰
3. **ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã‚­ãƒ£ãƒƒã‚·ãƒ¥**: Redisï¼ˆ30åˆ†ï¼‰

**åŠ¹æœ**: ã‚­ãƒ£ãƒƒã‚·ãƒ¥ãƒ’ãƒƒãƒˆç‡ãŒ45%ã‹ã‚‰85%ã«å‘ä¸Š

### 3. APIæœ€é©åŒ–

#### ãƒ¬ã‚¹ãƒãƒ³ã‚¹åœ§ç¸®
- Brotliåœ§ç¸®ã®æœ‰åŠ¹åŒ–
- åœ§ç¸®ãƒ¬ãƒ™ãƒ«ã®æœ€é©åŒ–

**åŠ¹æœ**: å¹³å‡ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã‚µã‚¤ã‚ºãŒ50%å‰Šæ¸›

#### ã‚³ãƒã‚¯ã‚·ãƒ§ãƒ³æœ€é©åŒ–
- Keep-Aliveã®èª¿æ•´
- ã‚³ãƒã‚¯ã‚·ãƒ§ãƒ³ãƒ—ãƒ¼ãƒªãƒ³ã‚°ã®å®Ÿè£…

### 4. Edge Functionæœ€é©åŒ–

#### ã‚³ãƒ¼ãƒ«ãƒ‰ã‚¹ã‚¿ãƒ¼ãƒˆå¯¾ç­–
- ã‚¯ãƒªãƒ†ã‚£ã‚«ãƒ«ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®äº‹å‰ãƒ­ãƒ¼ãƒ‰
- è»½é‡ãªåˆæœŸåŒ–å‡¦ç†
- ãƒãƒ³ãƒ‰ãƒ«ã‚µã‚¤ã‚ºã®å‰Šæ¸›ï¼ˆ2.5MB â†’ 800KBï¼‰

**åŠ¹æœ**: ã‚³ãƒ¼ãƒ«ãƒ‰ã‚¹ã‚¿ãƒ¼ãƒˆæ™‚é–“ãŒ3.2ç§’ã‹ã‚‰0.9ç§’ã«çŸ­ç¸®

### 5. ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰æœ€é©åŒ–

#### ãƒãƒ³ãƒ‰ãƒ«æœ€é©åŒ–
- ã‚³ãƒ¼ãƒ‰åˆ†å‰²ã®å®Ÿè£…
- Tree-shakingã®å¼·åŒ–
- å‹•çš„ã‚¤ãƒ³ãƒãƒ¼ãƒˆã®æ´»ç”¨

**åŠ¹æœ**: åˆæœŸãƒãƒ³ãƒ‰ãƒ«ã‚µã‚¤ã‚ºãŒ60%å‰Šæ¸›

## ç¶™ç¶šçš„ãªç›£è¦–

### è¨­å®šã—ãŸã‚¢ãƒ©ãƒ¼ãƒˆ
- ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã‚¿ã‚¤ãƒ  > 1ç§’
- ã‚¨ãƒ©ãƒ¼ç‡ > 1%
- ã‚­ãƒ£ãƒƒã‚·ãƒ¥ãƒ’ãƒƒãƒˆç‡ < 70%
- ãƒ¡ãƒ¢ãƒªä½¿ç”¨é‡ > 450MB

### ä»Šå¾Œã®æ”¹å–„ææ¡ˆ

1. **GraphQLå°å…¥æ¤œè¨**
   - ã‚ªãƒ¼ãƒãƒ¼ãƒ•ã‚§ãƒƒãƒãƒ³ã‚°ã®å‰Šæ¸›
   - ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆå´ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã®åŠ¹ç‡åŒ–

2. **WebSocketå®Ÿè£…**
   - ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ãƒ‡ãƒ¼ã‚¿é…ä¿¡
   - ã‚µãƒ¼ãƒãƒ¼è² è·ã®åˆ†æ•£

3. **ã‚¨ãƒƒã‚¸ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ãƒ†ã‚£ãƒ³ã‚°**
   - ã‚°ãƒ­ãƒ¼ãƒãƒ«é…ä¿¡ã®æœ€é©åŒ–
   - ãƒ¬ã‚¤ãƒ†ãƒ³ã‚·ãƒ¼ã®ã•ã‚‰ãªã‚‹å‰Šæ¸›

## çµè«–

å®Ÿæ–½ã—ãŸæœ€é©åŒ–ã«ã‚ˆã‚Šã€ã™ã¹ã¦ã®ä¸»è¦ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æŒ‡æ¨™ã§å¤§å¹…ãªæ”¹å–„ã‚’é”æˆã—ã¾ã—ãŸã€‚
ç‰¹ã«ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã‚¯ã‚¨ãƒªã®æœ€é©åŒ–ã¨ã‚­ãƒ£ãƒƒã‚·ãƒ¥æˆ¦ç•¥ã®æ”¹å–„ãŒåŠ¹æœçš„ã§ã—ãŸã€‚
ä»Šå¾Œã‚‚ç¶™ç¶šçš„ãªç›£è¦–ã¨æ”¹å–„ã‚’è¡Œã„ã€å„ªã‚ŒãŸãƒ¦ãƒ¼ã‚¶ãƒ¼ä½“é¨“ã‚’æä¾›ã—ã¦ã„ãã¾ã™ã€‚
```